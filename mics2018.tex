 % This is sigproc-sp.tex -FILE FOR V2.6SP OF ACM_PROC_ARTICLE-SP.CLS
% OCTOBER 2002
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V2.6SP
% LaTeX2e document class file for Conference Proceedings submissions.
%
%----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.6SP) *DOES NOT* produce:
%     1) The Permission Statement
%     2) The Conference (location) Info information
%     3) The Copyright Line with ACM data
%     4) Page numbering
%
% However, both the CopyrightYear (default to 2002) and the ACM Copyright Data
% (default to X-XXXXX-XX-X/XX/XX) can still be over-ridden by whatever the author
% inserts into the source .tex file.
% e.g.
% \CopyrightYear{2003} will cause 2003 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
%
%---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert' your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org
%
% For tracking purposes - this is V2.6SP - OCTOBER 2002


\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in}

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
%\usepackage[all]{xy}
\usepackage{float}
%\usepackage{subfigure}
\usepackage{hyperref}
\usepackage{url}
\usepackage{parskip}

%% Elena's favorite green (thanks, Fernando!)
\definecolor{ForestGreen}{RGB}{34,139,34}
\definecolor{BlueViolet}{RGB}{138,43,226}
\definecolor{Coquelicot}{RGB}{255, 56, 0}
\definecolor{Teal}{RGB}{2,132,130}
%Uncomment this if you want to show work-in-progress comments
\newcommand{\comment}[1]{{\bf \tt  {#1}}}
% Uncomment this if you don't want to show comments
%\newcommand{\comment}[1]{}
\newcommand{\emcomment}[1]{\textcolor{ForestGreen}{\comment{Elena: {#1}}}}
\newcommand{\todo}[1]{\textcolor{blue}{\comment{To Do: {#1}}}}
\newcommand{\tscomment}[1]{\textcolor{Teal}{\comment{Tony: {#1}}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagestyle{plain}
%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\setpagenumber{50}
%\CopyrightYear{2002} % Allows default copyright year (2002) to be
%over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data
%(X-XXXXX-XX-X/XX/XX) to be over-ridden.
% --- End of Author Metadata ---

\title{Implementing Novice Friendly Error Messages in Clojure}
%\subtitle{[Extended Abstract \comment{DO WE NEED THIS?}]
%\titlenote{}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.
%
% Up to the first three authors are aligned under the title;
% use the \alignauthor commands below to handle those names
% and affiliations. Add names, affiliations, addresses for
% additional authors as the argument to \additionalauthors;
% these will be set for you without further effort on your
% part as the last section in the body of your article BEFORE
% References or any Appendices.

\author{
Charlot Shaw \\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris, MN 56267\\
shawx538@morris.umn.edu
}
\maketitle
\thispagestyle{empty}
%\alcomment{Should these say @morris.umn.edu?}

\section*{\centering Abstract}
Clojures promise as an educational language taught to first time programmers is
limited by its error messages, which show its Java underpinnings. The messages
are generated by the Java code executing the Clojure program, and so generally
focus on Java perspective, to the obscuration of Clojure relevant information.
\emcomment{The second part of this sentence is grammatically ambiguous; rewrite}
By using these messages, along with the information granted by Clojure.Spec contracts
 error messages can be reformatted into beginner friendly, near plain language representations.
\emcomment{However, by providing Clojure.Spec contracts, as well as utilizing other Clojure features,  
these messages can be rewritten into more beginner-friendly wording.}
 By integrating the re-formatting code into the Clojure middleware nREPL, the
 transformation can be accomplished without disturbing programmers' workflows, and be easily
 used in \emcomment{incorporated into} Integrated Development Environments. 
We present a proof of concept implementation
 of \emcomment{integrating} beginner friendly error messages in \emcomment{into} Clojure
\emcomment{via nREPL}.

\newpage
\setcounter{page}{1}

\section{Introduction}
Clojure~\cite{Hickey:2008}, amongst other functional languages, has gained attention in recent years
in part for its management of state and concurrency.
Running on the Java Virtual Machine (JVM), Clojure has a number of advantages for beginning students.
Its Lisp style syntax and elegant core library work together to let beginners learn easily, while
its ties to the JVM keep it relevant as students progress into later courses.
However, from an educational perspective, it has a significant flaw in the form of error messages.
As Clojure code runs in the JVM, its errors take the structure and terminology of Java error messages,
and so are confusing to new students. They can understand the source of the error,
but not how the system presents it to them.
For example, a user who accidentally called addition on a boolean needs
 to understand the Java object hierarchy, casting,
 and the classes involved to fully understand what is meant by
 ``java.lang.classCastException java.lang.Boolean cannot be cast to java.lang.Number'',
whereas the mental overhead required to understand
``In function + the first argument {\tt true} must be a number, but is a boolean''
 is significantly lower, with the latter being closer to a plain language
 description of the issue.
 In order to overcome these problems,
 we have explored possibilities for integrating customized error messages
 with commonly used tools in the Clojure programming community.

\section{Error Messages in Clojure}
Clojure is hosted and interpreted in the JVM, as a Java program.
Clojure code can either be loaded by a running Clojure process, or
compiled Ahead Of Time (AOT compilation) into Java bytecode. In either case,
even simple Clojure code mid-execution is a complex Java program,
and any exceptions thrown are thrown as Java errors.
From the viewpoint of the JVM, the entirety of the Clojure process is
part of the users program, and so error messages include large amounts
of data about the underlying state of the Java classes that implement Clojure.
What information regarding the error that remains unobscured is still
phrased as a Java error, forcing a Clojure user into learning
the underlying Java code. 
\emcomment{Simplify the previous sentence}
This undue onus on the beginner,
unfamiliar with programming in general, is unreasonable.
However, the large amounts of information in a Clojure error
can be part of processing down the error for beginners.
\emcomment{I am not sure what this means}

\section{Clojure Spec}
A second piece of the information required can be sourced from Clojure Spec~\cite{spec}
which is a recently added library within Clojure, dealing with runtime validation of
the structure of data within a program. 
\emcomment{Give an example: Spec can be used to set up runtime
type checking for function arguments, for instance to verify that an argument used 
as a list index is a non-negative integer.}
These specifications, or contracts, can be applied to
 the arguments of function calls, allowing erroneous function calls to have
customized error messages that explain how the invocation did not meet the usage pattern
 needed \emcomment{Say: when a wrong type of argument is passed to a function - instead of the second part of the sentence}. 
By providing Spec specifications for the Core library of Clojure,
 we can cover every function that a novice will be able to call, and thus catch
 any miscalled functions with detailed Spec error messages.
 This information can be captured by our system, and as a result
 let us access information such as the actual values that caused the errors 
\emcomment{which are often not included in default Clojure error messages}.
Note that Spec only provides errors for function parameters; for syntax errors or other kinds of 
runtime exceptions, we need to source our data from the original Java error messages.
Between Spec error messages and the original Java error messages, we have enough
information to leverage the tools built by the
 University of Minnesota Morris research group, as soon we can integrate
 our process with the larger Clojure ecosystem.

\section{Clojure, REPL and the IDE}
Clojure is homoiconic, meaning that a Clojure program is also a Clojure datastructure.
 Evaluating every values in that structure is
equivalent to running the program.
This in part allows a Clojure process to read in data, process it as a program
and display the results back to the programmer and awaiting the next input.
 This common pattern is referred to
as the Read-Eval-Print-Loop (REPL), and programmers use it to test and build up
individual parts of their programs functions. This pattern of development is
referred to as REPL-Driven and is frequently used in Clojure community.
\comment{can I say ''practically all'' here?}
 Most Clojure Integrated Development Environments (IDEs) feature REPLs for
 user convenience. Outside of developer experimentation, the REPL mechanism is also used
by the Clojure process to load in new Clojure code for execution in a running program,
omitting the Print step as necessary.
Spanning both evaluation of code, and the preparation of output back to the user,
the REPL is the prime location for our system to be implemented.
However, building our own custom REPL is not advisable, as it limits the
integration possibilities, needing IDEs to be customized to support it.
Instead, the ideal position for our code is within an module loaded
by a popular, expandable REPL implementation.

\section{nREPL}
nREPL\comment{cite} is a community standard implementation of the REPL concept,
 using a Client/Server model. It is integrated in Leiningen
 (A project management system common in the Clojure community) as a client and server.
 Plugins that utilize nREPL exist for Emacs, vim, InelliJ Idea, Atom, and Eclipse\comment{cite}, amongst others.
It works by passing messages from the client, to be executed on the server.
nREPL allows a set middleware to modify messages, providing utilities
like interruptible evaluations or independent user sessions.
Custom middleware can be added, such as ours can be added by simply
modifying a projects configuration file. Once our code is added,
it listens for messages coming back from the server
marked to be displayed to the users as errors.
it customizes the error messages, and then reinserts them into the middleware stack
to reach the user. As it is using the same message propagation scheme as an unmodified nREPL,
IDEs should pick up and display the new error messages with little trouble.
This also does not change or affect anything on the server side, so there should
be no side effects.

\section{Conclusion}
Between Clojure default error messages, and Clojure Spec
we have all the information we need to modify error messages, using the
tools created by prior works by the University of Minnesota Morris research group. \comment{cite}
Using nREPL middleware lets us place our code seamlessly into the users
workflow, in a way that would not violate the expectations of more advanced users.
 Taken together our system shows a proof of concept for how Clojure
error messages can be modified for beginners, and allow Clojure to fulfill
its promise as an educational language for first time programmers.

\section{Acknowledgments}
This work was supported in part by Morris Academic Partnership (MAP) stipend at UMM.


\bibliographystyle{acm}
\bibliography{mics2018}

\end{document}
